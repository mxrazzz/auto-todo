# ðŸ§© This is your GitHub Actions workflow file
# Every workflow file must live inside .github/workflows/
# The file extension is always .yml or .yaml (both work the same)

name: Python CI with Pytest # ðŸ·ï¸ This is just a name for the workflow (shows up in GitHub Actions tab)

on: # âš™ï¸ This defines WHEN the workflow runs
  push: # ðŸš€ Runs every time you push new code
    branches: [main] # ðŸ§  You can change this to any branch (e.g. 'dev')
  pull_request: # ðŸ‘€ Runs when someone opens or updates a pull request
    branches: [main]

jobs: # ðŸ§± A workflow is made up of one or more jobs
  build: # ðŸ§° We'll call this job "build"
    runs-on: ubuntu-latest # ðŸ’» This tells GitHub what OS to use in the cloud (Ubuntu VM)

    steps: # ðŸ“œ A job has multiple 'steps'
      # ðŸš€ OPTIMIZATION 1: FASTER CODE DOWNLOAD
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1 # ï¿½ This tells the action to only download the latest version of your code, not the whole history.

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.10"

      # ðŸš€ OPTIMIZATION 2: CACHING DEPENDENCIES
      - name: Cache pip dependencies
        uses: actions/cache@v4
        with:
          # This is the path where pip stores its cache on the runner.
          path: ~/.cache/pip
          # This is the unique "key" for the cache.
          # 'runner.os' includes the OS in the key (e.g., 'Linux').
          # 'hashFiles' creates a unique hash from your requirements.txt file.
          # If requirements.txt changes, the key changes, and a new cache is created.
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          # This tells the cache action to restore the cache even if the key doesn't have an exact match.
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
        # ðŸ§  If the cache was restored, this step will be much faster because it will find the packages already installed.

      - name: Run tests and generate coverage report
        id: coverage # Give this step an ID so we can reference its output
        run: |
          # --cov=main: Tells pytest-cov to measure coverage for the 'main.py' file.
          # --cov-report=json: Generates a 'coverage.json' file for the badge.
          pytest --cov=main --cov-report=json
          # Extract the coverage percentage and set it as a GitHub Actions output
          COVERAGE=$(cat coverage.json | jq .totals.percent_covered_display)
          echo "coverage=$COVERAGE" >> $GITHUB_OUTPUT

      - name: Create coverage badge
        uses: shields/generator@v2
        with:
          label: "Coverage"
          message: ${{ steps.coverage.outputs.coverage }}%
          color: "green"
          style: "flat"
          path: "badge.svg" # The output path for the badge SVG file

      - name: Upload coverage badge as artifact
        uses: actions/upload-artifact@v4
        with:
          name: coverage-badge
          path: badge.svg
